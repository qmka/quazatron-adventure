# Инструкция по использованию движка текстовых приключений Quazatron Adventure

## 0. Вступление

Quazatron Adventure - игровой движок, написанный на языке JavaScript и служащий для создания игр в жанре текстового приключения. Для работы с движком от разработчика требуется понимание основ языка программирования JavaScript.

На данный момент инструкция готова в черновом варианте и в будущем будет дополнена.

## 1. Готовим файлы index.html и styles.css

`index.html` - файл с разметкой всех игровых элементов, которые будут присутствовать на экране пользователя. Именно этот файл нужно запустить, чтобы сыграть в игру.

`styles.css` - файл со стилями оформления всех игровых элементов.

Проще всего взять оба файла из демо-игры и переделать их под свои нужды, или же оставить всё как есть. Придумывая оформление демо-игры, я ориентировался в первую очередь на классические adventure-игры с графикой, например, Kayleth. Сверху располагается экран с картинкой локации, ниже - текст описания локации, ещё ниже выводятся ответы программы на действия пользователя. И в самом низу находится строка для ввода комманд.

Если вы всё же хотите переделать стандартный index.html, то обратите внимание, что для Quazatron Adventure обязательно наличие блоков <div> со следующими id:
* `<div id="image"></div>` - блок для отображения графики. В планах сделать возможность отключения графики, если разработчик хочет сделать чисто текстовую игру, но пока вы можете закомментировать строки, связанные с выводом в id="image", в файле modules/screen-ctrl.js.
* `<div id="screen"></div>` - основной игровой блок, по умолчанию сюда выводится описание локации и реакция программы на действия пользователя.
* `<div id="input-area"><input id="input-field" type="text" autofocus></div>` - строка ввода комманд пользователя. На данный момент это стандартный html-элемент input, в дальнейшем, возможно, я запилю какую-нибудь более аутентичную строку ввода.

В файле styles.css нужно сохранить следующие стили: `.action-ask, .inventory-item, .location-item, .encounter`.
Они задают цвет, соответственно, сообщениям с реакцией программы на ввод пользователя, предметам в инвентаре, предметам в локации и игровым объектам, с которыми игрок может взаимодействовать.

И, наконец, подключение движка к index.html производится следующим способом:
`<script type="module" src="app.js"></script>`

## 2. Создаём словари

Для создания своей собственной игры вам потребуется изменить файлы в папке `gamedata`. Этого достаточно, если вы хотите создать игру, но не хотите лезть в сам движок. Все файлы в данной папке написаны на языке javascript и содержат исходные данные и игровую логику.

Первое, с чего имеет смысл начинать в работе над игрой, это создание словарей. В файлах-словарях находятся все слова, которые понимает игра. В Quazatron Adventure таких словаря три: файл `verbs.js` с глаголами, `objects.js` с существительными и `adjectives.js` с прилагательными.

Каждый словарь представляет собой **массив** из **объектов** JavaScript: `[ { слово 1 }, { слово 2 }, ... { слово n} ]`. Каждому слову соответствует свой цифровой id, а также ряд свойств.

Рассмотрим каждый из словарей подробнее.

### verbs.js

В словарь `verbs` входят игровые команды-глаголы. По умолчанию каждая команда игрока должна начинаться с глагола или со служебного слова / сокращения (далее все служебные слова и глаголы я буду именовать командами, для простоты).

Команды с id от 0 до 13 зарезервированы программой. Их изъятие из словаря нарушит логику работы игры.

| id | Команда           |
| -- | -----------------:|
| 0  | с (идти на север) |
| 1  | в (идти на восток)|
| 2  | ю (идти на юг)    |
| 3  | з (идти на запад) |
| 4  | х (идти наверх)   |
| 5  | н (идти вниз)     |
| 6  | инфо              |
| 7  | выход             |
| 8  | и (инвентарь)     |
| 9  | сохранить         |
| 10 | загрузить         |
| 11 | взять             |
| 12 | положить          |
| 13 | о (осмотреть)     |

Начиная с id=14 вы можете создавать свои команды.

Каждая команда-глагол может иметь несколько форм, которые перечисляются в свойстве `forms`. Данное свойство представляет собой массив, в котором находятся варианты написания команды в виде строк, синонимы. Так, для глагола id=11, который говорит программе, что нужно взять предмет, можно прописать синонимы: "взять", "поднять", "подобрать", "брать" и так далее. Вы можете прописывать любое количество синонимов как в повелительном наклонении (например, "возьми"), так и в неопределённой форме ("взять").

У команд, начинающихся с id=11 (а также всех команд, которые добавляет в словарь разработчик), должно быть задано также свойство `method`, которое показывает, какая функция соответствует данной команде в объекте `encounters`, отвечающем за игровую логику. Подробнее про это см. далее.

### adjectives.js

В словарь `adjectives` входят используемые в игре прилагательные.

У каждого прилагательного есть два свойства: его id и свойство `forms`, массив, в котором находятся все варианты написания прилагательного (аналогично тому, как это сделано у глаголов). 

Привязка прилагательных к определённым предметам или игровым объектам производится в словаре объектов `objects.js`.

**Важное замечание!** Не следует создавать прилагательные "для красоты", так как работа с прилагательными усложняет ввод для пользователя (ему нужно будет вводить и прилагательное, и существительное, чтобы игра его поняла). Создавайте прилагательные только для тех случаев, когда в игре используется несколько однотипных объектов, различающихся каким-либо свойством (чаще всего цветом): золотая, серебряная и медная монеты; красная, синяя и жёлтая кнопки; круглая и треугольная таблетки и так далее.

### objects.js

В словарь `objects` входят все существительные, на ввод которых игра должна как-либо реагировать. Как правило, это предметы, которые может использовать игрок, а также игровые объекты или персонажи, с которыми игрок может взаимодействовать. Впрочем, ничто не мешает вам использовать абстракции. Например, в игре может использоваться команда `"посмотри время"`, которая покажет, сколько сейчас времени, если у игрока есть часы. В этом случае `"время"` также должно быть добавлено в словарь объектов.

Для каждого объекта, помимо id, задаётся ряд свойств:
* `name` - строка, выводящаяся как название предмета в инвентаре. Требуется только для предметов, для всех остальных объектов можно не задавать.
* `forms` - массив словоформ, аналогично такому же свойству словарей глаголов и прилагательных. Здесь имеет смысл прописать слово во всех падежах, чтобы предугадать любой вариант ввода пользователя (например, вот так игрок может взаимодействовать с объектом *тролль*: *убей тролля*, *поговори с троллем*, *дай денег троллю*, *спроси о тролле* и так далее).
* `canHold` - true, если это предмет, который можно поместить в инвентарь; false для всех остальных объектов
* `desc` - описание предмета, которое выводится игроку по команде "осмотреть". Требуется только для предметов. Описание не-предметов реализуется не через свойство, а через метод `examine` объекта `encounters`.
* `adjective` - в это свойство прописывается id прилагательного, которое будет привязано к этому объекту. В демо-игре для примера сделаны две монеты - серебряная и медная - с одинаковыми `forms`, но разными id и adjective. Если к объекту не привязано прилагательное, то свойству `adjective` должно быть присвоено значение -1.

**Важно!** Во избежание путаницы и сбоев в работе движка следует сначала прописывать предметы, а только после них все остальные объекты!

## 3. Создаём игровые локации

Вся информация о локациях, которые может посетить игрок, задаётся в объекте `locations` файла `locations.js`.

Объект `locations` так же, как и объекты словарей, представляет собой массив объектов JavaScript: `[ { локация 1 }, { локация 2 }, ... { локация n }]`.

Для объекта каждой локации задаётся четыре свойства:

* id - цифровой id локации
* desc - описание локации, которое выводится на экран
* img - изображение, соответствующее данной локации
* dir - объект, содержащий информацию о переходах из локации.

Объект dir построен следующим образом:
```
dir: {
        n: 2,
        e: -1,
        s: 0,
        w: -1,
        u: -1,
        d: -1
    }
```
Его свойства n, e, s, w, u, d содержат номер локации, в которую игрок переходит при перемещении, соответственно, на север, на восток, на юг, на запад, вверх и вниз. Если переместиться в направлении нельзя, то вместо номера присваивается -1.

Обратите внимание, что в `dir` задаются все возможные направления. То есть, если путь на восток теоретически возможен, но его преграждает запертая дверь или монстр, то в свойстве `e` всё равно указывается номер следующей локации, а ограничение перемещения нужно будет прописать в `encounters` (об этом - дальше).

## 4. Задаём переменные и объекты игрового состояния

Файл `initial-data.js` содержит все данные, которые изменяются в процессе игры, а также их первоначальное состояние.

В нём вы должны задать пять переменных:

**const defaultLocation** - присвойте этой переменной номер стартовой локации

**const initialItemPlaces** - объект, содержащий данные по начальному местоположению всех предметов. Свойства объекта задаются в виде `id предмета: id локации`. Если изначально предмет не находится ни в одной из локаций, вместо id локации присваивается -1.

**const initialFlags** - объект, содержащий игровые флаги (триггеры, переключатели). Свойства объекта задаются в виде `флаг: начальное состояние (true / false`).

Флаги используются в игровой логике в функциях объекта `encounters`, который вы запрограмируете далее.

Например, нам нужно отслеживать состояние двери: закрыта она или открыта. Для этого создаём флаг `isDoorOpened` и присваиваем ему начальное значение false (потому что дверь закрыта). После того, как игрок откроет дверь, флаг `isDoorOpened` поменяется на true.

**const initialCounters** - объект, содержащий игровые счётчики. Счётчики аналогичны флагам, но если флаг принимает булевые значения true / false, то счётчики принимают числовые значения. Счётчики можно использовать, например, для подсчёта игровых очков или ходов, которые сделал игрок. Как и флаги, счётчики используются в объекте `encounters`.

**const initialInventory** - массив, содержащий в себе id всех предметов, которые находятся в инвентаре с начала игры.

## 5. Задаём изображения и тексты "по умолчанию"

За изображения и тексты по умолчанию отвечает файл `default-data.js`, который содержит два объекта: `defaultTexts` и `defaultImages`.

В `defaultTexts` прописываются все текстовые сообщения, не связанные с игровой логикой: тексты стартового экрана, экранов выигрыша и проигрыша; дефолтные ответы на служебные команды, призывы игрока к действию в тех или иных ситуациях и так далее.

В `defaultImages` указываются изображения, которые следует выводить для стартового экрана, экранов выигрыша и проигрыша. 

## 6. Прописываем игровую логику

А теперь самое интересное: объект `encounters`, который находится в файле `encounters.js` и содержит в себе всю игровую логику. По сравнению со всеми предыдущими объектами и массивами `encounters` является самым сложным, более того, работа с этим объектом требует от разработчика игры базовых знаний в языке JavaScript, поэтому разберём его детально.

Объект `encounters` содержит ряд дефолтных методов, удаление которых может привести к потере движком работоспособности. Помимо дефолтных методов разработчик добавляет свои методы, соответствующие командам (их название должно совпадать со свойством `method` в словаре `verbs`).

Для выполнения тех или иных действий внутри собственных методов объект `encounters` активно использует методы *игровых классов*, код которых располагается в папке `classes`. И, для того, чтобы разобраться с тем, как работает `encounters`, для начала разберёмся с этими методами.

### Методы игровых классов, в которых хранится текущее состояние игры

К игровым классам относится пять классов: `Counters, Flags, Inventory, ItemPlaces и CurrentLocation`. Данные классы используются для хранения и обработки соответствующих им игровых состояний: счётчиков, флагов, инвентаря, мест расположения предметов и локации, в которой находится игрок. Методы игровых классов используются для получения данных из классов либо их изменения.

#### Методы Counters - работа со счётчиками
* *Counters.init(state)* - инициализация счётчиков;
* *Counters.get(x)* - получить значение счётчика x;
* *Counters.getAll()* - получить объект, содержащий все счётчики;
* *Counters.set(x, y)* - установить в счётчик x значение y;
* *Counters.increase(x)* - увеличить значение счётчика x на 1;
* *Counters.decrease(x)* - уменьшить значение счётчика x на 1;

#### Методы Flags - работа с флагами
* *Flags.init(state)* - инициализация флагов;
* *Flags.get(x)* - получить значение флага x;
* *Flags.getAll()* - получить объект, содержащий все флаги;
* *Flags.toggle(x)* - переключить флаг;

#### Методы Inventory - работа с инвентарём
* *Inventory.init(state)* - инициализация инвентаря;
* *Inventory.clear()* - очистка инвентаря;
* *Inventory.addItem(id)* - добавить в инвентарь предмет id;
* *Inventory.removeItem(id)* - убрать из инвентаря предмет id;
* *Inventory.includes(id)* - возвращает true, если предмет id есть в инвентаре, иначе false;
* *Inventory.getAll()* - возвращает массив с id предметов в инвентаре;
* *Inventory.getItemsTextList()* - возвращает строку с перечислением предметов в инвентаре через запятую (которая выводится по команде "и");

#### Методы ItemPlaces - работа с расположением предметов
* *ItemPlaces.init(state)* - инициализация первоначального расположения предметов;
* *ItemPlaces.set(itemId, locationId)* - помещает предмет itemId в локацию locationId;
* *ItemPlaces.get(id)* - возвращает id локации, в которой находится предмет;
* *ItemPlaces.getAll()* - возвращает объект со всеми местами расположения предметов;
* *ItemPlaces.getLocationItemsList(id)* - возвращает строку с перечислением всех предметов в локации через запятую (которая выводится после вывода описания локации);

#### Методы CurrentLocation - работа с текущей локацией
* *CurrentLocation.set(id)* - устанавливает локацию id для игрока как текущую;
* *CurrentLocation.get()* - возвращает номер текущей локации;

---

### Дефолтные методы объекта encounters

Теперь переходим, собственно, к изучению дефолтных методов объекта encounters и созданию собственной логики

#### addDescription()

Метод служит для добавления к стандартному описанию локаций текста, который зависит от текущего состояния игры. Добавочный текст хранится в переменной encounter. Если добавочный текст выводить не надо, то метод возвращает пустую строку, иначе метод возвращает содержание переменной encounter.

Пример:
```
switch (currentLocation) {
            case 7:
                if (!Flags.get("isTrollKilled")) encounter = 'Путь на восток преграждает толстый <span class="encounter">тролль</span>.';
                break;
            case 8:
                if (Flags.get("isLadderLeanToTree")) encounter = 'К дереву приставлена <span class="encounter">лестница</span>.';
                break;
```
Если игрок находится в локации id = 7 и флаг `isTrollKilled` = false, то к описанию локации добавляется строка про то, что путь преграждает тролль.
Если игрок находится в локации id = 8 и флаг `isLadderLeanToTree` = true, то к описанию локации добавляется строка про то, к дереву приставлена лестница.

#### checkPlayerObstacles(direction)

Метод возвращает текст, который выводится, если игрок пытается пройти в направлении, которое по логике игры пока ему недоступно.

Пример:
```
const currentLocation = CurrentLocation.get();
    if (currentLocation === 7 && !Flags.get("isTrollKilled") && direction === 'e') {
        return "Тролль рычит и не даёт мне пройти.";
    }
```
Если игрок находится в локации id = 7 и флаг `isTrollKilled` = false и игрок хочет пройти на восток ("e"), то игра ему ответит сообщением о том, что тролль не даёт ему пройти.

#### setCounters()

Метод вызывается на каждом игровом ходу и позволяет менять значения счётчиков.

Пример:
```
Counters.increase('gameTurns');
```
Каждый ход счётчик `gameTurns` увеличивается на 1.

#### getGameOverText()

Метод возвращает текст, который выводится на экране проигрыша. Цель метода - дать разработчику кастомизировать текст в зависимости от того, как умер игрок.

Пример:
```
if (Flags.get("isDiedFromFish")) {
        return 'Вы почувствовали острую боль в животе и умерли. Глупо, конечно, заканчивать это приключение, отравившись протухшей рыбой.';
    }
    return defaultTexts.defaultGameOverText;
```
Если флаг `isDiedFromFish` установлен в значение true, то возвращается текст про то, что игрок умер от протухшей рыбы. По умолчанию игроку возвращается дефолтный текст проигрыша (см. пункт 5 данного руководства).

#### getUniqueEncounter()

Метод позволяет реализовать игровую логику в обход стандартного алгоритма программы.
В демо-игре этот метод используется, чтобы выкидывать игрока из комнаты с ведьмой, когда тот совершает неправильное действие:
```
getUniqueEncounter(verbId, objectIds) {
    let answer, flag = false;

    if (CurrentLocation.get() === 27 && !Flags.get("isWitchKilled")) {
        flag = true;
        if (verbId === 32 && objectIds.includes(25)) {
            if (Inventory.includes(10)) {
                Flags.toggle("isWitchKilled");
                Inventory.removeItem(10);
                answer = "Вы отразили заклятье мечом, и оно ударило прямо в ведьму! Издав истошный крик, ведьма рассыпалась в пыль. К сожалению, меч тоже не уцелел.";
            } else {
                CurrentLocation.set(17);
                answer = "Вам нечем отразить заклятье. Заклятье ударяет вам в грудь и выкидывает отсюда в комнату с решёткой."
            }
        } else {
            CurrentLocation.set(17);
            answer = "Вы не успеваете ничего сделать. Заклятье ударяет вам в грудь и выкидывает отсюда в комнату с решёткой.";
        }
    }

    return {
        answer,
        flag
    }
}
```
Если игрок находится в локации id = 27, и ведьма ещё жива, то внутренний флаг функции `flag` устанавливается в true. Далее происходит проверка условий, благодаря которым игрок может убить ведьму (правильная команда и присутствие меча в инвентаре).
После этого метод возвращает ответ, который выводится игроку, а также внутренний флаг. Данный флаг показывает движку, что следует вернуться к следующему игровому циклу, игнорируя обработку любых команд. Благодаря этому игрок не может выполнить ни одного действия, кроме единственно верного.

#### take(itemId) и drop(itemId)

Данные методы служат для дополнения стандартной функциональности глаголов "взять" и "положить". В демо-игре с помощью этого метода можно забрать лестницу, прислонённую к дереву, и потерять монетку.

Метод строится на основе условий `if`, и если ни одно из условий не выполняется, то возвращает дефолтный ответ.

Пример:

```
 if ((itemId === 11 || itemId === 12) && Inventory.includes(itemId) && (CurrentLocation.get() === 6 || CurrentLocation.get() === 12)) {
        Inventory.removeItem(itemId);
        return "Вы бросили монетку на землю, и она укатилась в пропасть.";
    }

    return "У меня нет этого.";
```
Если предмет - серебряная или медная монетка и если локация id = 6 или 12, то при попытке положить монетку вы её теряете.

#### examine(id)

Метод возвращает строку, которая показывается пользователю, если тот хочет осмотреть тот или иной объект. При этом к осмотру объекта можно прицепить другие действия. Так, например, в демо-игре при попытке осмотреть дрова игрок обнаруживает в них ключ:
```
if (objectId === 4 && Inventory.includes(4)) {
    let answer = objects[4].desc;
    if (!Flags.get("isAxeRevealed")) {
        Flags.toggle("isAxeRevealed");
        ItemPlaces.set(5, currentLocation);
        answer += " Осматривая вязанку, вы обнаружили спрятанный в ней топор.";
    }
    return answer;
}
```

Если же сложной логики не требуется, то достаточно просто вывести строку с описанием объекта:
```
if (currentLocation === 7 && !Flags.get("isTrollKilled") && objectId === 17) {
    return "Это огромный мерзкий зелёный тролль. Ничего, кроме страха и омерзения, не вызывает.";
}
```

Для вывода описания объекта, которое занесено в словарь `objects` в свойство `desc` объекта, отдельной логики прописывать не нужно.

#### Пользовательские функции

Для каждого глагола, кроме зарезервированных (см. пункт 2 инструкции), вам как разработчику требуется создать отдельный метод в объекте `encounters` и прописать его название в словаре `verbs` в свойстве `method` глагола.

Возьмём для примера метод buy, связанный с глаголом "купить":
```
buy(objectIds) {
    if (objectIds.includes(7) && CurrentLocation.get() === 5) {
        if (Inventory.includes(11)) {
            Inventory.removeItem(11);
            Inventory.addItem(7);
            return "Вы купили у старушки лампу за серебряную монету.";
        } else if (Inventory.includes(12)) {
            return 'Старушка пробует монету на зуб и говорит: "Нет, это не серебро!"';
        } else {
            return "У вас нет денег."
        }
    }

    return "Вы не можете это купить";
},
```
В каждый метод вы ОБЯЗАТЕЛЬНО должны передать массив objectIds, содержащий id объектов, которые указал в своём вводе игрок. Проверка наличия id того или иного объекта в objectIds производится при помощи стандартного для массивов JavaScript свойства includes.

*Использование массива позволяет обрабатывать команды с разным порядком существительных. В этом случае команда "Купи у старушки лампу" и "Купи лампу у старушки" выполнится одинаково успешно.*

В коде приведённого выше метода buy следующая логика. Если игрок упомянул в команде лампу (id = 7), и если он при этом находится в локации id = 5, то происходит проверка, есть ли у игрока в инвентаре серебряная монета. Если есть, то монета убирается из инвентаря, а лампа туда добавляется, и игра выдаёт игроку сообщение о том, что он купил лампу. Если у игрока нет серебряной, но есть медная монета, игра сообщает игроку, что такая монета не подходит. Если у игрока нет никакой монеты, то программа сообщает, что у него нет денег. И, наконец, если игрок использует команду купить в каком-либо другом контексте, то программа сообщает ему, что он не может ничего здесь купить.

## 7. Продолжение следует ...

Данной инструкции должно хватить для создания простейшей игры. В дальнейшем я дополню инструкцию информацией о логике работы парсера и другими полезными штуками.